}
Lengths <- vector(mode="numeric",length=length(EDGES[,1]))
for(j in 1:dim(EDGES)[1]){
which.edge(tree, EDGES[j,2]) -> Lengths[j]
}
if(length(Lengths)==1){Lengths->to_index} else {sample(Lengths,1)->to_index}
WHERE = tree$edge[to_index,2]
tree$edge.length[to_index]->LLL
MIN=0
MAX=LLL
runif(1,MIN,MAX)->POS
while(POS==MIN | POS==MAX){
runif(1,MIN,MAX)->POS
}
bind.tip(tree, new.tip, edge.length=NULL, where=WHERE, position=POS)->tree
}
return(tree)
}
# A function to stick species at random within a polyphyletic clade
add_to_polyphyletic<-function(tree, species, polyphyletic.insertion=c("freq", "large", "all")){
'%!in%' <- function(x,y)!('%in%'(x,y))
species<-gsub(" ", "_",species)
species.genus<- word(species, 1, sep="_")[!duplicated(word(species, 1, sep="_"))]
if(length(species.genus)>1){stop("Species from more than 1 genera are included")}
new.tree<-tree
genus<- species.genus
list<- data.frame(species=tree$tip.label)
taxa.vector<- as.vector(list[word(list$species, 1, sep="_")==genus,]) #genus species within the tree. This vector is used for all species to be added
if(length(taxa.vector)==0){stop(paste0("Genus ", genus, " is not included in your tree."))}
if(polyphyletic.insertion=="freq"){
for(p in 1:length(species)){
sticked.species<- species[p]
sticking.species<- sample(taxa.vector, 1) #a species from the vector is chosen (this allows a probability based on frequencies inside each group)
sticking.tip<- which(new.tree$tip.label==sticking.species) #tip value
parent<-new.tree$edge[new.tree$edge[,2]==sticking.tip,1] #direct ancestor
siblings<- new.tree$tip.label[getDescendants(new.tree, parent)][!is.na(new.tree$tip.label[getDescendants(new.tree, parent)])] #ancestor's descendants
if(length(siblings[word(siblings,1,sep="_")==genus])==1){new.tree<- add_to_singleton(new.tree,sticking.species,new.tips=sticked.species)} #its siblings are from a different genus; it is a singleton inside another clade
if(length(siblings[word(siblings,1,sep="_")==genus]) >1){ #at least one sibling is from the same genus
while(length(word(siblings,1,sep="_")[!duplicated(word(siblings,1,sep="_"))])==1){ #tip and parent upstream until they are from different genera
sticking.tip<-parent
parent<-new.tree$edge[new.tree$edge[,2]==sticking.tip,1]
siblings<- new.tree$tip.label[getDescendants(new.tree, parent)][!is.na(new.tree$tip.label[getDescendants(new.tree, parent)])]
}
gen.MRCA<- findMRCA(tree = new.tree,tips = siblings[word(siblings, 1, sep="_")==genus]) #MCRA form same genus siblings; probably always the same as "sticking tip"; but may change
grouped<- new.tree$tip.label[getDescendants(new.tree, gen.MRCA)][!is.na(new.tree$tip.label[getDescendants(new.tree, gen.MRCA)])] #non-node descendants
grouped.gen<- word(grouped,1,sep="_")[!duplicated(word(grouped,1,sep="_"))] #MRCA descendants
if(length(grouped.gen)==1){new.tree<- add_into_node(new.tree, gen.MRCA, sticked.species)} #monophyletic subgruoup
if(length(grouped.gen) >1){ #always paraphyletic subgroup, it can't be mono or poly
intruders<-grouped[word(grouped, 1, sep="_")!=genus]
if(length(intruders)==1){new.tree<- add_into_node(new.tree, gen.MRCA, sticked.species)}else{ # singleton intruders; added as monophyletic
intruders.MRCA<- findMRCA(tree = new.tree,tips = intruders)
new.tree<- add_into_paraphyletic_node(new.tree, new.tip=sticked.species, group.node = gen.MRCA, intern.node = intruders.MRCA) #monophyletic intruders; added as paraphyletic
}}}}
}
if(polyphyletic.insertion=="large"){
groups<- rep(list(NA), times=length(taxa.vector))
names(groups)<-taxa.vector
for( t in 1:length(taxa.vector)){
taxon<- taxa.vector[t]
taxon.tip<- which(new.tree$tip.label==taxon) #tip value
parent<-new.tree$edge[new.tree$edge[,2]==taxon.tip,1] #direct ancestor
siblings<- new.tree$tip.label[getDescendants(new.tree, parent)][!is.na(new.tree$tip.label[getDescendants(new.tree, parent)])] #ancestor's descendants
if(length(siblings[word(siblings,1,sep="_")==genus])==1){groups[[t]]<- taxon} #its siblings are from a different genus; it is a singleton inside another clade
if(length(siblings[word(siblings,1,sep="_")==genus]) >1){ #at least one sibling is from the same genus
while(length(word(siblings,1,sep="_")[!duplicated(word(siblings,1,sep="_"))])==1){ #tip and parent upstream until they are from different genera
taxon.tip<-parent
parent<-new.tree$edge[new.tree$edge[,2]==taxon.tip,1]
siblings<- new.tree$tip.label[getDescendants(new.tree, parent)][!is.na(new.tree$tip.label[getDescendants(new.tree, parent)])]
}
gen.MRCA<- findMRCA(tree = new.tree,tips = siblings[word(siblings, 1, sep="_")==genus]) #MCRA form same genus siblings; probably always the same as "sticking tip"; but may change
grouped<- new.tree$tip.label[getDescendants(new.tree, gen.MRCA)][!is.na(new.tree$tip.label[getDescendants(new.tree, gen.MRCA)])] #non-node descendants
grouped.gen<- word(grouped,1,sep="_")[!duplicated(word(grouped,1,sep="_"))] #MRCA descendants
if(length(grouped.gen)==1){groups[[t]]<- grouped}  #monophyletic subgruoup
if(length(grouped.gen) >1){ #always paraphyletic subgroup, it can't be mono or poly
groups[[t]]<- grouped[word(grouped, 1, sep="_")==genus]}}
}
group.types<-rep(list(NA), times=length(taxa.vector))
names(group.types)<-taxa.vector
for( t in 1:length(taxa.vector)){
taxon<- taxa.vector[t]
taxon.tip<- which(new.tree$tip.label==taxon) #tip value
parent<-new.tree$edge[new.tree$edge[,2]==taxon.tip,1] #direct ancestor
siblings<- new.tree$tip.label[getDescendants(new.tree, parent)][!is.na(new.tree$tip.label[getDescendants(new.tree, parent)])] #ancestor's descendants
if(length(siblings[word(siblings,1,sep="_")==genus])==1){group.types[[t]]<- "singleton"} #its siblings are from a different genus; it is a singleton inside another clade
if(length(siblings[word(siblings,1,sep="_")==genus]) >1){ #at least one sibling is from the same genus
while(length(word(siblings,1,sep="_")[!duplicated(word(siblings,1,sep="_"))])==1){ #tip and parent upstream until they are from different genera
taxon.tip<-parent
parent<-new.tree$edge[new.tree$edge[,2]==taxon.tip,1]
siblings<- new.tree$tip.label[getDescendants(new.tree, parent)][!is.na(new.tree$tip.label[getDescendants(new.tree, parent)])]
}
gen.MRCA<- findMRCA(tree = new.tree,tips = siblings[word(siblings, 1, sep="_")==genus]) #MCRA form same genus siblings; probably always the same as "sticking tip"; but may change
grouped<- new.tree$tip.label[getDescendants(new.tree, gen.MRCA)][!is.na(new.tree$tip.label[getDescendants(new.tree, gen.MRCA)])] #non-node descendants
grouped.gen<- word(grouped,1,sep="_")[!duplicated(word(grouped,1,sep="_"))] #MRCA descendants
if(length(grouped.gen)==1){group.types[[t]]<- "monophyletic"}  #monophyletic subgruoup
if(length(grouped.gen) >1){ #always paraphyletic subgroup, it can't be mono or poly
group.types[[t]]<- "paraphyletic"} }}
m<-max(as.numeric(lengths(groups)))
group.types<- group.types[lengths(groups)==m]
groups<- groups[lengths(groups)==m]
slot<-sample(1:length(groups), size = 1)
group<- groups[[slot]]
group.type <- group.types[[slot]]
for(s in 1:length(species)){
sp<-species[s]
if(group.type=="monophyletic"){
MRCA<- findMRCA(new.tree, tips=group)
new.tree<-add_into_node(tree = new.tree, node = MRCA, new.tip = sp)}
if(group.type=="paraphyletic"){
MRCA<- findMRCA(new.tree, tips=group)
intruders<-new.tree$tip.label[getDescendants(new.tree, MRCA)][!is.na(new.tree$tip.label[getDescendants(new.tree, MRCA)])]
intruders<- intruders[word(intruders, 1, sep="_")!=genus]
intruders.MRCA<- findMRCA(new.tree, tips=intruders)
new.tree<-add_into_paraphyletic_node(tree=new.tree, new.tip = sp, group.node = MRCA, intern.node = intruders.MRCA)}
}
}
if(polyphyletic.insertion=="all"){
for(s in 1:length(species)){
sp<- species[s]
MRCA<- findMRCA(new.tree, taxa.vector)
new.tree<- add_into_node(new.tree, node = MRCA, new.tip = sp)
}
}
return(new.tree)
}
RANDTIP<- function(tree, species.table, type=c("random", "genus.polytomy", "family.polytomy", "order.polytomy", "class.polytomy"),
aggregate.subspecies=TRUE, insertion=c("random", "middle","long"), prob=TRUE){
start<- Sys.time()
if(type=="random"){
species.table$using.taxa<-NA #New column with the name for the first round
for(i in 1:nrow(species.table)){
if(is.na(species.table$aggregate.subspecies[i])){    #para los NA (en la tabla no hay especificadas excepciones) se aplica lo marado en la funcion
if(aggregate.subspecies==TRUE){species.table$using.taxa[i]<-paste0(word(species.table$taxon[i],1, sep="_"), "_",word(species.table$taxon[i],2, sep="_"))}
else{species.table$using.taxa[i]<-species.table$taxon[i]}
next}
if(species.table$aggregate.subspecies[i]==0){species.table$using.taxa[i]<-species.table$taxon[i] #para los especificados como 0 no se agrupa
next}
if(species.table$aggregate.subspecies[i]==1){species.table$using.taxa[i]<-paste0(word(species.table$taxon[i],1, sep="_"), "_",word(species.table$taxon[i],2, sep="_"))}} # the ones specified with a 1 are clustered
species.table.dupl <- species.table[ duplicated(species.table$using.taxa),]
species.table <-      species.table[!duplicated(species.table$using.taxa),]
newtree<- tree
taxa <- species.table$using.taxa[!duplicated(species.table$using.taxa)]
taxa<- gsub(" ", "_", taxa)
taxa <- taxa[taxa%!in%tree$tip.label]
taxa.genera<- word(taxa, 1, sep="_")[!duplicated(word(taxa, 1, sep="_"))]
#taxa.genera<-sample(taxa.genera, length(taxa.genera), replace = F)
}else{
species.table$using.taxa <-species.table$taxon  #In polytomy cases, names are not changed
newtree<- tree
taxa <- species.table$using.taxa[!duplicated(species.table$using.taxa)]
taxa<- gsub(" ", "_", taxa)
taxa <- taxa[taxa%!in%tree$tip.label]
taxa.genera<- word(taxa, 1, sep="_")[!duplicated(word(taxa, 1, sep="_"))]
taxa.genera<-sample(taxa.genera, length(taxa.genera), replace = F)
} #using name preparation
if(type=="genus.polytomy"){
genera<- species.table$genus[!duplicated(species.table$genus)]
for(p in 1:length(genera)){
genus<- genera[p]
genus.taxa<- species.table$taxon[species.table$genus==genus]
genus.taxa<- genus.taxa[genus.taxa%!in%tree$tip.label]
genus.genera<- species.table$genus[species.table$genus==genus] #this is redundant, but keeps the structure
union.tips<-tree$tip.label[word(tree$tip.label, 1, sep="_")%in%genus.genera]   #species (tips) within class IN ORIGINAL TREE
if(length(genus.taxa)==0){next}
if(length(union.tips)==0){
family<- species.table$family[species.table$genus==genus][!duplicated(species.table$family[species.table$genus==genus])]
family.taxa<- species.table$taxon[species.table$family==family]
family.taxa<- family.taxa[family.taxa%!in%tree$tip.label]
family.genera<- species.table$genus[species.table$family==family]
union.tips<-tree$tip.label[word(tree$tip.label, 1, sep="_")%in%family.genera]   #species (tips) within class IN ORIGINAL TREE
if(length(family.taxa)==0){next}
if(length(union.tips)==0){
order<-species.table$order[species.table$family==family][!duplicated(species.table$order[species.table$family==family])]
order.taxa<- species.table$taxon[species.table$order==order]
order.taxa<- order.taxa[order.taxa%!in%tree$tip.label]
order.genera<- species.table$genus[species.table$order==order]
union.tips<-tree$tip.label[word(tree$tip.label, 1, sep="_")%in%order.genera]   #species (tips) within class IN ORIGINAL TREE
if(length(order.taxa)==0){next}
if(length(union.tips)==0){
class<- species.table$class[species.table$order==order][!duplicated(species.table$class[species.table$order==order])]
class.taxa<- species.table$taxon[species.table$class==class]
class.taxa<- class.taxa[class.taxa%!in%tree$tip.label]
class.genera<- species.table$genus[species.table$class==class]
union.tips<-tree$tip.label[word(tree$tip.label, 1, sep="_")%in%class.genera]   #species (tips) within class IN ORIGINAL TREE
if(length(class.taxa)==0){next}
if(length(union.tips)==0){message(paste0("ATTENTION: genus ", class.genera, " was not included as no Class coincidences were found"))####JOIN TO UPPER TAXONOMIC LEVEL
next}
newtree<- polytomy_over_node(tree = newtree, species = class.taxa, node=findMRCA(newtree, tips=union.tips), insertion = insertion)####JOIN TO UPPER TAXONOMIC LEVEL
next}
if(length(union.tips)==1){node<- which(newtree$tip.label==union.tips)}else{node<-findMRCA(newtree, tips=union.tips)}
newtree<- polytomy_over_node(tree = newtree, species = order.taxa, node=node, insertion = insertion)####JOIN TO UPPER TAXONOMIC LEVEL
next}
if(length(union.tips)==1){node<- which(newtree$tip.label==union.tips)}else{node<-findMRCA(newtree, tips=union.tips)}
newtree<- polytomy_over_node(tree = newtree, species = family.taxa, node=node, insertion = insertion)####JOIN TO UPPER TAXONOMIC LEVEL
next}
if(length(union.tips)==1){node<- which(newtree$tip.label==union.tips)}else{node<-findMRCA(newtree, tips=union.tips)}
newtree<- polytomy_over_node(tree = newtree, species = genus.taxa, node=node, insertion = insertion)
}}
if(type=="family.polytomy"){
families<- species.table$family[!duplicated(species.table$family)]
for(p in 1:length(families)){
family<- families[p]
family.taxa<- species.table$taxon[species.table$family==family]
family.taxa<- family.taxa[family.taxa%!in%tree$tip.label]
family.genera<- species.table$genus[species.table$family==family]
union.tips<-tree$tip.label[word(tree$tip.label, 1, sep="_")%in%family.genera]   #species (tips) within class IN ORIGINAL TREE
if(length(family.taxa)==0){next}
if(length(union.tips)==0){
order<-species.table$order[species.table$family==family][!duplicated(species.table$order[species.table$family==family])]
order.taxa<- species.table$taxon[species.table$order==order]
order.taxa<- order.taxa[order.taxa%!in%tree$tip.label]
order.genera<- species.table$genus[species.table$order==order]
union.tips<-tree$tip.label[word(tree$tip.label, 1, sep="_")%in%order.genera]   #species (tips) within class IN ORIGINAL TREE
if(length(order.taxa)==0){next}
if(length(union.tips)==0){
class<- species.table$class[species.table$order==order][!duplicated(species.table$class[species.table$order==order])]
class.taxa<- species.table$taxon[species.table$class==class]
class.taxa<- class.taxa[class.taxa%!in%tree$tip.label]
class.genera<- species.table$genus[species.table$class==class]
union.tips<-tree$tip.label[word(tree$tip.label, 1, sep="_")%in%class.genera]   #species (tips) within class IN ORIGINAL TREE
if(length(class.taxa)==0){next}
if(length(union.tips)==0){message(paste0("ATTENTION: genus ", class.genera, " was not included as no Class coincidences were found"))####JOIN TO UPPER TAXONOMIC LEVEL
next}
newtree<- polytomy_over_node(tree = newtree, species = class.taxa, node=findMRCA(newtree, tips=union.tips), insertion = insertion)####JOIN TO UPPER TAXONOMIC LEVEL
next}
if(length(union.tips)==1){node<- which(newtree$tip.label==union.tips)}else{node<-findMRCA(newtree, tips=union.tips)}
newtree<- polytomy_over_node(tree = newtree, species = order.taxa, node=node, insertion = insertion)####JOIN TO UPPER TAXONOMIC LEVEL
next}
if(length(union.tips)==1){node<- which(newtree$tip.label==union.tips)}else{node<-findMRCA(newtree, tips=union.tips)}
newtree<- polytomy_over_node(tree = newtree, species = family.taxa, node=node, insertion = insertion)}}
if(type=="order.polytomy"){
orders<- species.table$order[!duplicated(species.table$order)]
for(p in 1:length(orders)){
order<-orders[p]
order.taxa<- species.table$taxon[species.table$order==order]
order.taxa<- order.taxa[order.taxa%!in%tree$tip.label]
order.genera<- species.table$genus[species.table$order==order]
union.tips<-tree$tip.label[word(tree$tip.label, 1, sep="_")%in%order.genera]   #species (tips) within class IN ORIGINAL TREE
if(length(order.taxa)==0){next}
if(length(union.tips)==0){
class<- species.table$class[species.table$order==order][!duplicated(species.table$class[species.table$order==order])]
class.taxa<- species.table$taxon[species.table$class==class]
class.taxa<- class.taxa[class.taxa%!in%tree$tip.label]
class.genera<- species.table$genus[species.table$class==class]
union.tips<-tree$tip.label[word(tree$tip.label, 1, sep="_")%in%class.genera]   #species (tips) within class IN ORIGINAL TREE
if(length(class.taxa)==0){next}
if(length(union.tips)==0){message(paste0("ATTENTION: genus ", class.genera, " was not included as no Class coincidences were found"))####JOIN TO UPPER TAXONOMIC LEVEL
next}
newtree<- polytomy_over_node(tree = newtree, species = class.taxa, node=findMRCA(newtree, tips=union.tips), insertion = insertion)####JOIN TO UPPER TAXONOMIC LEVEL
next}
if(length(union.tips)==1){node<- which(newtree$tip.label==union.tips)}else{node<-findMRCA(newtree, tips=union.tips)}
newtree<- polytomy_over_node(tree = newtree, species = order.taxa, node=node, insertion = insertion)
}}
if(type=="class.polytomy"){
classes<- species.table$class[!duplicated(species.table$class)]
for(p in 1:length(classes)){
class<- classes[p]
class.taxa<- species.table$taxon[species.table$class==class]
class.taxa<- class.taxa[class.taxa%!in%tree$tip.label]
class.genera<- species.table$genus[species.table$class==class]
union.tips<-tree$tip.label[word(tree$tip.label, 1, sep="_")%in%class.genera]   #species (tips) within class IN ORIGINAL TREE
if(length(class.taxa)==0){next}
if(length(union.tips)==0){message(paste0("ATTENTION: genus ", class.genera, " was not included as no Class coincidences were found"))####JOIN TO UPPER TAXONOMIC LEVEL
next}
if(length(union.tips)==1){node<- which(newtree$tip.label==union.tips)}else{node<-findMRCA(newtree, tips=union.tips)}
newtree<- polytomy_over_node(tree = newtree, species = class.taxa, node=node, insertion = insertion)}}
if(type=="random"){
for(i in 1: length(taxa.genera)){        #loop 1
gen.start<- Sys.time()
genus<- taxa.genera[i]
genus.type<-species.table$genus.type[species.table$genus==genus][!duplicated(species.table$genus.type[species.table$genus==genus])]
genus.taxa <- taxa[word(taxa, 1, sep="_")==genus] #genus taxa selection
genus.taxa <- sample(genus.taxa, length(genus.taxa), replace = F) #order randomized
grouped.taxa<-species.table$using.taxa[!is.na(species.table$relative.species)]#tips with no "relatives" information selected (they will be bound as monophyletic)
grouped.taxa<-grouped.taxa[grouped.taxa%in%genus.taxa]
genus.taxa<-genus.taxa[genus.taxa%!in%grouped.taxa]
if(length(grouped.taxa)>0){    #if "grouped.taxa" exist
for( j in 1:length(grouped.taxa)){
grouping.taxa<- species.table$relative.species[species.table$using.taxa==grouped.taxa[j]]
grouping.taxa<-gsub(" ","",grouping.taxa)
grouping.taxa<- strsplit(grouping.taxa, split = ",")[[1]]
grouping.taxa<-grouping.taxa[grouping.taxa%in%tree$tip.label] #taxa to be grouped hich are in the tree are selected
if(length(grouping.taxa)==1){
newtree<- add_to_singleton(newtree, singleton = grouping.taxa, new.tips = grouped.taxa[j])  #first is added as singleton
} else{
node<-findMRCA(newtree, tips = grouping.taxa)
newtree<- add_into_node(newtree, new.tip = grouped.taxa[j],node = node)} #the rest ar added as monophyletic
rm(j, node, grouping.taxa)}
next}
#forbidden.groups
forb.genera<- species.table[species.table$genus.type=="MONOPHYLETIC"|species.table$genus.type=="PARAPHYLETIC","genus"]
forb.genera<-forb.genera[!duplicated(forb.genera)]
forbidden.groups<- rep(list(NA),length(forb.genera))
if(length(forbidden.groups)>0){
for(l in 1:length(forb.genera)){
forbidden.groups[[l]]<- species.table[species.table$genus==forb.genera[l], "taxon"]
}}
#Hereon we will work with genus.taxa; i.e., no grouped tips.
if(genus.type=="MONOPHYLETIC"){
for( j in 1:length(genus.taxa)){
newtree<- add_to_monophyletic(newtree, new.tip = genus.taxa[j])#for the given genus, being MP, taxa are added one by one as MP
rm(j)}}
if(genus.type=="PARAPHYLETIC"){
for( j in 1:length(genus.taxa)){
newtree<- add_to_paraphyletic(newtree, new.tip = genus.taxa[j])#for the given genus, being PaP, taxa are added one by one as PaP
rm(j)}}
if(genus.type=="POLYPHYLETIC"){
newtree<- add_to_polyphyletic(newtree, species  = genus.taxa)#for the given genus, being PoP, taxa are added one by one as PoP
}
if(genus.type=="SINGLETON GENUS"){   #for the given genus, being singleton, all tips are added in one step
newtree<- add_to_singleton(newtree, singleton = tree$tip.label[word(tree$tip.label,1,sep="_")== genus], new.tips = genus.taxa)
}
if(genus.type=="NOT INCLUDED"){
genus.synonyms<- species.table$synonim.genus[species.table$genus==genus&!is.na(species.table$synonim.genus)]#looking for synonim information...
genus.siblings<- species.table$sibling.genus[species.table$genus==genus&!is.na(species.table$sibling.genus)]#... or sibling information
genus.synonyms.tips<-species.table$using.taxa[species.table$genus==genus&!is.na(species.table$synonim.genus)]
genus.siblings.tips<-species.table$using.taxa[species.table$genus==genus&!is.na(species.table$sibling.genus)]
genus.taxa.NO.except<-genus.taxa[genus.taxa%!in%c(genus.synonyms.tips,genus.siblings.tips)]#taxa without exceptions
if(length(genus.synonyms)>0){#for genera with synonym exceptions
for(i in 1:length(genus.synonyms.tips)){
genus.synonyms.tips[i]<-paste0(genus.synonyms[i], "_",genus.synonyms.tips[i]) #synonym genus pasted to the begginig of the name; must be in the tree
new.genus<- word(genus.synonyms.tips[i], 1, sep="_")
new.genus.type<-species.table$genus.type[species.table$genus==new.genus][!duplicated(species.table$genus.type[species.table$genus==new.genus])]
if(new.genus.type=="MONOPHYLETIC"){
newtree<- add_to_monophyletic(newtree, new.tip = genus.synonyms.tips[i])}
if(new.genus.type=="PARAPHYLETIC"){
newtree<- add_to_paraphyletic(newtree, new.tip = genus.synonyms.tips[i])}
if(new.genus.type=="POLYPHYLETIC"){
newtree<- add_to_polyphyletic(newtree, species = genus.synonyms.tips[i])}
if(new.genus.type=="SINGLETON GENUS"){
newtree<- add_to_singleton(newtree,
singleton = newtree$tip.label[word(newtree$tip.label,1,sep="_")== new.genus],
new.tips = genus.synonyms.tips[i])}
newtree$tip.label<-gsub(pattern = genus.synonyms.tips[i],
replacement = species.table$using.taxa[species.table$genus==genus&!is.na(species.table$synonim.genus)][i],
x =newtree$tip.label )
}}
if(length(genus.siblings)>0){#for genera with sibling exceptions
if(length(genus.siblings[!duplicated(genus.siblings)])>1){stop(paste0("Multiple genus siblings for genus ",genus))}
new.genus<- genus.siblings[!duplicated(genus.siblings)]
genus.siblings.tips<-sample(genus.siblings.tips, length(genus.siblings.tips), replace = F)
adding.node<- findMRCA(newtree, tips = newtree$tip.label[word(newtree$tip.label, 1, sep="_")==new.genus])
newtree<-add_over_node(newtree, new.tip = genus.siblings.tips[1], node=adding.node)#it is added over the sibling genus MCRA
newtree<-add_to_singleton(newtree, singleton = genus.siblings.tips[1],new.tips =  genus.siblings.tips[2:length(genus.siblings.tips)])#te rest are added to singleton
}
if(length(genus.taxa.NO.except)>0){#for those with no exceptions, they will be added randomly within family, order or class
fam<-species.table$family[species.table$using.taxa%in%genus.taxa.NO.except][!duplicated(species.table$family[species.table$using.taxa%in%genus.taxa.NO.except])]
genera<- species.table$genus[species.table$family==fam]
family.taxa<- newtree$tip.label[word(newtree$tip.label,1, sep="_")%in%genera]
if(length(family.taxa)>0){
newtree<- add_into_node_exceptions(tree=newtree, node=findMRCA(tree = newtree,tips = family.taxa),new.tip = genus.taxa.NO.except[1], exception.list = forbidden.groups)
if(length(genus.taxa.NO.except)>1){newtree<- add_to_singleton(tree=newtree, singleton = genus.taxa.NO.except[1],new.tips = genus.taxa.NO.except[2:length(genus.taxa.NO.except)])}
}else{
ord<-species.table$order[species.table$using.taxa%in%genus.taxa.NO.except][!duplicated(species.table$family[species.table$using.taxa%in%genus.taxa.NO.except])]
genera<- species.table$genus[species.table$order==ord]
order.taxa<- newtree$tip.label[word(newtree$tip.label,1, sep="_")%in%genera]
if(length(order.taxa)>0){
newtree<- add_into_node_exceptions(tree=newtree, node=findMRCA(tree = newtree,tips = order.taxa),new.tip = genus.taxa.NO.except[1], exception.list = forbidden.groups)
if(length(genus.taxa.NO.except)>1){newtree<- add_to_singleton(tree=newtree, singleton = genus.taxa.NO.except[1],new.tips = genus.taxa.NO.except[2:length(genus.taxa.NO.except)])}
}else{
cla<-species.table$class[species.table$using.taxa%in%genus.taxa.NO.except][!duplicated(species.table$family[species.table$using.taxa%in%genus.taxa.NO.except])]
genera<- species.table$genus[species.table$class==cla]
class.taxa<- newtree$tip.label[word(newtree$tip.label,1, sep="_")%in%genera]
if(length(class.taxa)>0){
newtree<- add_into_node_exceptions(tree=newtree, node=findMRCA(tree = newtree,tips = class.taxa),new.tip = genus.taxa.NO.except[1], exception.list = forbidden.groups)
if(length(genus.taxa.NO.except)>1){newtree<- add_to_singleton(tree=newtree, singleton = genus.taxa.NO.except[1],new.tips = genus.taxa.NO.except[2:length(genus.taxa.NO.except)])}
}else{
stop(paste0("Genus ", genus, " has no family, order or class relatives"))}}}
}
}
gen.end<- Sys.time()
print(paste0(i, "/", length(taxa.genera), " (",round(i/length(taxa.genera)*100, 2), " %). Gen. ", genus, " (", genus.type,", ", length(genus.taxa)," tips). ",
round(as.numeric(difftime(gen.end, gen.start, units = "secs")), 2), " sec. out of ",
round(as.numeric(difftime(gen.end, start,     units = "mins")), 2), " mins)"))
}
# phase 2. subspecies
if(nrow(species.table.dupl)>0){ #species grouped
rep.taxa <-species.table.dupl$taxon #species are found
rep.taxa.species<- species.table.dupl$using.taxa[!duplicated(species.table.dupl$using.taxa)]#subspecies' species
for (r in 1:length(rep.taxa.species)){
ssps <- rep.taxa[paste0(word(rep.taxa, 1, sep="_"),"_",word(rep.taxa, 2, sep="_"))==rep.taxa.species[r]] #subspecies within species are selected
ssps <- sample(ssps, length(ssps), replace = F) #order randomized
sp.to.add<- newtree$tip.label[paste0(word(newtree$tip.label,1, sep="_"), "_", word(newtree$tip.label,2, sep="_"))== rep.taxa.species[r] ]
newtree<- add_to_singleton(newtree, singleton = sp.to.add, new.tips = ssps) #subspecies are added to their sister as singleton
print(paste0(r, " out of ", length(rep.taxa.species), ". Species ", rep.taxa.species[r],  round(i/length(rep.taxa.species)*100, 2), " %"))
}
}
for(n in 1:nrow(species.table)){  #original names are returned
if(species.table$using.taxa[n]== species.table$taxon[n]){next}
if(species.table$using.taxa[n]%!in% newtree$tip.label){next}
if(species.table$using.taxa[n]%in% newtree$tip.label){
newtree$tip.label[newtree$tip.label==species.table$using.taxa[n]]<-species.table$taxon[n]
print(paste0("name correction: ", n, "/", nrow(species.table), " (", round(n/nrow(species.table)*100, 2), " %)"))
}}
}
return(newtree)
}
#PREPARATION####
setwd("E:/UNI/4. DOCTORADO/OTROS/Comunidades Halófitas/phylogenies")
rm(list = setdiff(ls(), lsf.str()))#eliminar todo menos funciones
load("E:/UNI/4. DOCTORADO/OTROS/Comunidades Halófitas/phylogenies/GBOTB.extended.rda")
listado_especies<- read.xlsx("E:/UNI/4. DOCTORADO/OTROS/Comunidades Halófitas/phylogenies/species_TFM_Ana.xlsx")
#taxonomy.Ana<- phylo.taxonomy(listado_especies$match.name)
#write.xlsx(taxonomy.Ana, "randtip.taxonomy_Ana.xlsx")
taxonomy.Ana<-read.xlsx("E:/UNI/4. DOCTORADO/OTROS/Comunidades Halófitas/phylogenies/randtip.taxonomy_Ana.xlsx")
included<-GBOTB.extended$tip.label[word(GBOTB.extended$tip.label, 1, sep="_")%in%taxonomy.Ana$Genus]
GBOTB.pruned<-drop.tip(GBOTB.extended, GBOTB.extended$tip.label[-match(included, GBOTB.extended$tip.label  )])
rm(included, GBOTB.extended)
#complete.table<- phylo.table(species = listado_especies$match.name, tree = GBOTB.pruned, taxonomy = taxonomy.Ana)
#write.xlsx(complete.table, "complete.table_Ana.xlsx")
complete.table<-read.xlsx("E:/UNI/4. DOCTORADO/OTROS/Comunidades Halófitas/phylogenies/complete.table_Ana.xlsx")
rand.tree<-RANDTIP(tree = GBOTB.pruned, species.table = complete.table, type = "random",
aggregate.subspecies = TRUE, insertion = "random", prob = TRUE)
View(complete.table)
tree = GBOTB.pruned
species.table = complete.table
type = "random"
aggregate.subspecies = TRUE
insertion = "random"
prob = TRUE
if(type=="random"){
species.table$using.taxa<-NA #New column with the name for the first round
for(i in 1:nrow(species.table)){
if(is.na(species.table$aggregate.subspecies[i])){    #para los NA (en la tabla no hay especificadas excepciones) se aplica lo marado en la funcion
if(aggregate.subspecies==TRUE){species.table$using.taxa[i]<-paste0(word(species.table$taxon[i],1, sep="_"), "_",word(species.table$taxon[i],2, sep="_"))}
else{species.table$using.taxa[i]<-species.table$taxon[i]}
next}
if(species.table$aggregate.subspecies[i]==0){species.table$using.taxa[i]<-species.table$taxon[i] #para los especificados como 0 no se agrupa
next}
if(species.table$aggregate.subspecies[i]==1){species.table$using.taxa[i]<-paste0(word(species.table$taxon[i],1, sep="_"), "_",word(species.table$taxon[i],2, sep="_"))}} # the ones specified with a 1 are clustered
species.table.dupl <- species.table[ duplicated(species.table$using.taxa),]
species.table <-      species.table[!duplicated(species.table$using.taxa),]
newtree<- tree
taxa <- species.table$using.taxa[!duplicated(species.table$using.taxa)]
taxa<- gsub(" ", "_", taxa)
taxa <- taxa[taxa%!in%tree$tip.label]
taxa.genera<- word(taxa, 1, sep="_")[!duplicated(word(taxa, 1, sep="_"))]
#taxa.genera<-sample(taxa.genera, length(taxa.genera), replace = F)
}else{
species.table$using.taxa <-species.table$taxon  #In polytomy cases, names are not changed
newtree<- tree
taxa <- species.table$using.taxa[!duplicated(species.table$using.taxa)]
taxa<- gsub(" ", "_", taxa)
taxa <- taxa[taxa%!in%tree$tip.label]
taxa.genera<- word(taxa, 1, sep="_")[!duplicated(word(taxa, 1, sep="_"))]
taxa.genera<-sample(taxa.genera, length(taxa.genera), replace = F)
} #using name preparation
i<-375
genus<- taxa.genera[i]
i<-376
genus<- taxa.genera[i]
genus.type<-species.table$genus.type[species.table$genus==genus][!duplicated(species.table$genus.type[species.table$genus==genus])]
genus.taxa <- taxa[word(taxa, 1, sep="_")==genus] #genus taxa selection
genus.taxa <- sample(genus.taxa, length(genus.taxa), replace = F) #order randomized
findMRCA(tree, tips=genus.taxa)
genus.taxa
getMRCA(tree, tips=genus.taxa)
getMRCA(tree, tip=genus.taxa)
getMRCA(GBOTB.pruned, tip=genus.taxa)
x11
x11()
plot(tree)
x11()
findMRCA(tree, c("Abies_alba","Abies_pinsapo"))
findMRCA(tree, tips=genus.taxa)
findMRCA(tree, genus.taxa)
findMRCA(tree, c("Abies_alba","Abies_pinsapo"))
findMRCA(tree, as.vector(genus.taxa))
genus.taxa
"Plantago_loeflingii"%in%tree$tip.label
tree$tip.label[word(tree$tip.label,1, sep = "_")=="Plantago"]
tree$tip.label[word(tree$tip.label,1, sep = "_")=="Plantago"]->plantagos
findMRCA(tree, plantagos)
getDescendants(tree, 29180)
nodes<-getDescendants(tree, 29180)
tree$tip.label[nodes]
plot(splitTree(tree, split=list("node"=node, bp=0)[[2]]))
plot(splitTree(tree, split=list("node"=29180, bp=0)[[2]]))
plot(splitTree(tree, split=list("node"=29180, bp=0))[[2]])
plot(splitTree(tree, split=list("node"=29180, bp=0))[[2]])
new.tip<-"Plantago_1234"
genus<- word(new.tip, 1, sep="_")
sp.list<- data.frame(species=tree$tip.label)
taxa.vector<- as.vector(sp.list[word(sp.list$species, 1, sep="_")==genus,])
taxa.vector
if(length(taxa.vector)==0){stop(paste0("Genus ", genus, " is no included in yout tree."))}
MRCA<-findMRCA(tree = tree,tips = taxa.vector)
MRCA
descs<-getDescendants(tree, MRCA)
Desc.Tips<-tree$tip.label[getDescendants(tree, MRCA)][!is.na(tree$tip.label[getDescendants(tree, MRCA)])]
Desc.Tips
Intruder.Tips<-as.vector(Desc.Tips[word(Desc.Tips, 1, sep = "_")!= genus])
Intruder.Tips
if(length(Intruder.Tips)==0){stop(paste0("Genus ", genus, " is not paraphyletic"))}
if(length(Intruder.Tips)==1){newtree<-add_into_node( tree = tree, node = MRCA, new.tip = new.tip)}
intruderMCRA<-findMRCA(tree, tips = Intruder.Tips)
intruder.descs<-getDescendants(tree, intruderMCRA)
intruderMCRA
intruder.descs
intruder.descs
etDescendants(tree, intruderMCRA)
getDescendants(tree, intruderMCRA)
word(tree$tip.label[intruder.descs], 1, sep="_")
intruder.descs<-intruder.descs[!is.na(intruder.descs)]
intruder.descs
( genus %in% word(tree$tip.label[intruder.descs], 1, sep="_"))
#write.tree(tree, file = "trees/Arbol_sin_randomizaciones.tre")
sub.table<-complete.table[complete.table$genus=="Plantago"|complete.table$genus=="Pinus"]
#write.tree(tree, file = "trees/Arbol_sin_randomizaciones.tre")
sub.table<-complete.table[complete.table$genus=="Plantago"|complete.table$genus=="Pinus",]
rand.tree<-RANDTIP(tree = GBOTB.pruned, species.table = sub.table, type = "random",
aggregate.subspecies = TRUE, insertion = "random", prob = TRUE)
plot(rand.tree)
