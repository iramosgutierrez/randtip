getDescendants(tree, Parent, curr=NULL)->Desc_Par
Desc_Par<-c(Desc_Par[Desc_Par%in%getDescendants(tree, Child, curr=NULL)==FALSE & Desc_Par!=Child],Parent)
EDGES<-rbind(EDGES,tree$edge[tree$edge[,1]%in%Desc_Par & tree$edge[,2]!=Child,])
Child<-Parent
Parent<-getParent(tree,Parent)
EDGES <- rbind(EDGES,c(Parent,Child))
}
sum(DF[DF[,1]%in%EDGES[,1]&DF[,2]%in%EDGES[,2],3]) -> edges[i,5]
}
}
SS <- sample(1:dim(edges)[1],1,replace=FALSE,edges[,5])
tips1 = edges[SS,1:2]
tips2 = edges[SS,3:4]
tips1.char<- c(as.character(edges[SS,1]), as.character(edges[SS,2]))
tips2.char<- c(as.character(edges[SS,3]), as.character(edges[SS,4]))
N1<-findMRCA(tree, tips=tips1.char, "node")
if(duplicated(tips2.char)[2]==TRUE) {N2<-which(tree$tip.label==tips2.char[1])} else{N2<-findMRCA(tree, tips=tips2.char, "node")}
EDGES <- c(NA,NA)
Child=N2
getParent(tree,Child) -> Parent
EDGES <- rbind(c(Parent,Child))
while(Parent!=N1) {
getDescendants(tree, Parent, curr=NULL)->Desc_Par
Desc_Par<-c(Desc_Par[Desc_Par%in%getDescendants(tree, Child, curr=NULL)==FALSE & Desc_Par!=Child],Parent)
EDGES<-rbind(EDGES,tree$edge[tree$edge[,1]%in%Desc_Par & tree$edge[,2]!=Child,])
Child<-Parent
Parent<-getParent(tree,Parent)
EDGES <- rbind(EDGES,c(Parent,Child))
}
Lengths <- vector(mode="numeric",length=length(EDGES[,1]))
for(j in 1:dim(EDGES)[1]){
which.edge(tree, EDGES[j,2]) -> Lengths[j]
}
if(length(Lengths)==1){Lengths->to_index} else {sample(Lengths,1,replace=FALSE,DF[Lengths,3])->to_index}
WHERE = tree$edge[to_index,2]
tree$edge.length[to_index]->LLL
MIN=0
MAX=LLL
runif(1,MIN,MAX)->POS
while(POS==MIN | POS==MAX){
runif(1,MIN,MAX)->POS
}
bind.tip(tree, new.tip, edge.length=NULL, where=WHERE, position=POS)->tree
} else {
SS <- sample(1:dim(edges)[1],1)
tips1 = edges[SS,1:2]
tips2 = edges[SS,3:4]
tips1.char<- c(as.character(edges[SS,1]), as.character(edges[SS,2]))
tips2.char<- c(as.character(edges[SS,3]), as.character(edges[SS,4]))
N1<-findMRCA(tree, tips=tips1.char, "node")
if(duplicated(tips2.char)[2]==TRUE) {N2<-which(tree$tip.label==tips2.char[1])} else{N2<-findMRCA(tree, tips=tips2.char, "node")}
EDGES <- c(NA,NA)
Child=N2
getParent(tree,Child) -> Parent
EDGES <- rbind(c(Parent,Child))
while(Parent!=N1) {
getDescendants(tree, Parent, curr=NULL)->Desc_Par
Desc_Par<-c(Desc_Par[Desc_Par%in%getDescendants(tree, Child, curr=NULL)==FALSE & Desc_Par!=Child],Parent)
EDGES<-rbind(EDGES,tree$edge[tree$edge[,1]%in%Desc_Par & tree$edge[,2]!=Child,])
Child<-Parent
Parent<-getParent(tree,Parent)
EDGES <- rbind(EDGES,c(Parent,Child))
}
Lengths <- vector(mode="numeric",length=length(EDGES[,1]))
for(j in 1:dim(EDGES)[1]){
which.edge(tree, EDGES[j,2]) -> Lengths[j]
}
if(length(Lengths)==1){Lengths->to_index} else {sample(Lengths,1)->to_index}
WHERE = tree$edge[to_index,2]
tree$edge.length[to_index]->LLL
MIN=0
MAX=LLL
runif(1,MIN,MAX)->POS
while(POS==MIN | POS==MAX){
runif(1,MIN,MAX)->POS
}
bind.tip(tree, new.tip, edge.length=NULL, where=WHERE, position=POS)->tree
}
return(tree)
}
# A function to stick species at random within a polyphyletic clade
add_to_polyphyletic<-function(tree, species){
'%!in%' <- function(x,y)!('%in%'(x,y))
species<-gsub(" ", "_",species)
species.genus<- word(species, 1, sep="_")[!duplicated(word(species, 1, sep="_"))]
if(length(species.genus)>1){stop("Species from more than 1 genera are included")}
new.tree<-tree
genus<- species.genus
list<- data.frame(species=tree$tip.label)
taxa.vector<- as.vector(list[word(list$species, 1, sep="_")==genus,]) #genus species within the tree. This vector is used for all species to be added
if(length(taxa.vector)==0){stop(paste0("Genus ", genus, " is not included in your tree."))}
for(p in 1:length(species)){
sticked.species<- species[p]
sticking.species<- sample(taxa.vector, 1) #a species from the vector is chosen (this allows a probability based on frequencies inside each group)
sticking.tip<- which(new.tree$tip.label==sticking.species) #tip value
parent<-new.tree$edge[new.tree$edge[,2]==sticking.tip,1] #direct ancestor
siblings<- new.tree$tip.label[getDescendants(new.tree, parent)][!is.na(new.tree$tip.label[getDescendants(new.tree, parent)])] #ancestor's descendants
if(length(siblings[word(siblings,1,sep="_")==genus])==1){new.tree<- add_to_singleton(new.tree,sticking.species,new.tips=sticked.species)} #its siblings are from a different genus; it is a singleton inside another clade
if(length(siblings[word(siblings,1,sep="_")==genus]) >1){ #at least one sibling is from the same genus
while(length(word(siblings,1,sep="_")[!duplicated(word(siblings,1,sep="_"))])==1){ #tip and parent upstream until they are from different genera
sticking.tip<-parent
parent<-new.tree$edge[new.tree$edge[,2]==sticking.tip,1]
siblings<- new.tree$tip.label[getDescendants(new.tree, parent)][!is.na(new.tree$tip.label[getDescendants(new.tree, parent)])]
}
gen.MRCA<- findMRCA(tree = new.tree,tips = siblings[word(siblings, 1, sep="_")==genus]) #MCRA form same genus siblings; probably always the same as "sticking tip"; but may change
grouped<- new.tree$tip.label[getDescendants(new.tree, gen.MRCA)][!is.na(new.tree$tip.label[getDescendants(new.tree, gen.MRCA)])] #non-node descendants
grouped.gen<- word(grouped,1,sep="_")[!duplicated(word(grouped,1,sep="_"))] #MRCA descendants
if(length(grouped.gen)==1){new.tree<- add_into_node(new.tree, sticking.tip, sticked.species)} #monophyletic subgruoup
if(length(grouped.gen) >1){ #always paraphyletic subgroup, it can't be mono or poly
intruders<-grouped[word(grouped, 1, sep="_")!=genus]
if(length(intruders)==1){new.tree<- add_into_node(new.tree, sticking.tip, sticked.species)}else{ # singleton intruders; added as monophyletic
intruders.MRCA<- findMRCA(tree = new.tree,tips = intruders)
new.tree<- add_into_paraphyletic_node(new.tree, new.tip=sticked.species, group.node = gen.MRCA, intern.node = intruders.MRCA) #monophyletic intruders; added as paraphyletic
}}}}
return(new.tree)
}
set.seed(1234)
#randtip "MOTHER FUNCTION" ####
RANDTIP<- function(tree, species.table, type=c("random", "genus.polytomy", "family.polytomy", "order.polytomy", "class.polytomy"),
aggregate.subspecies=TRUE, insertion=c("random", "middle","long"), prob=TRUE){
if(type=="random"){
species.table$using.taxa<-NA #New column with the name for the first round
for(i in 1:nrow(species.table)){
if(is.na(species.table$aggregate.subspecies[i])){    #para los NA (en la tabla no hay especificadas excepciones) se aplica lo marado en la funcion
if(aggregate.subspecies==TRUE){species.table$using.taxa[i]<-paste0(word(species.table$taxon[i],1, sep="_"), "_",word(species.table$taxon[i],2, sep="_"))}
else{species.table$using.taxa[i]<-species.table$taxon[i]}
next}
if(species.table$aggregate.subspecies[i]==0){species.table$using.taxa[i]<-species.table$taxon[i] #para los especificados como 0 no se agrupa
next}
if(species.table$aggregate.subspecies[i]==1){species.table$using.taxa[i]<-paste0(word(species.table$taxon[i],1, sep="_"), "_",word(species.table$taxon[i],2, sep="_"))}} # the ones specified with a 1 are clustered
species.table.dupl <- species.table[ duplicated(species.table$using.taxa),]
species.table <-      species.table[!duplicated(species.table$using.taxa),]
newtree<- tree
taxa <- species.table$using.taxa[!duplicated(species.table$using.taxa)]
taxa<- gsub(" ", "_", taxa)
taxa <- taxa[taxa%!in%tree$tip.label]
taxa.genera<- word(taxa, 1, sep="_")[!duplicated(word(taxa, 1, sep="_"))]
taxa.genera<-sample(taxa.genera, length(taxa.genera), replace = F)
}else{
species.table$using.taxa <-species.table$taxon  #In polytomy cases, names are not changed
newtree<- tree
taxa <- species.table$using.taxa[!duplicated(species.table$using.taxa)]
taxa<- gsub(" ", "_", taxa)
taxa <- taxa[taxa%!in%tree$tip.label]
taxa.genera<- word(taxa, 1, sep="_")[!duplicated(word(taxa, 1, sep="_"))]
taxa.genera<-sample(taxa.genera, length(taxa.genera), replace = F)
} #using name preparation
if(type=="genus.polytomy"){
genera<- species.table$genus[!duplicated(species.table$genus)]
for(p in 1:length(genera)){
genus<- genera[p]
genus.taxa<- species.table$taxon[species.table$genus==genus]
genus.taxa<- genus.taxa[genus.taxa%!in%tree$tip.label]
genus.genera<- species.table$genus[species.table$genus==genus] #this is redundant, but keeps the structure
union.tips<-tree$tip.label[word(tree$tip.label, 1, sep="_")%in%genus.genera]   #species (tips) within class IN ORIGINAL TREE
if(length(genus.taxa)==0){next}
if(length(union.tips)==0){
family<- species.table$family[species.table$genus==genus][!duplicated(species.table$family[species.table$genus==genus])]
family.taxa<- species.table$taxon[species.table$family==family]
family.taxa<- family.taxa[family.taxa%!in%tree$tip.label]
family.genera<- species.table$genus[species.table$family==family]
union.tips<-tree$tip.label[word(tree$tip.label, 1, sep="_")%in%family.genera]   #species (tips) within class IN ORIGINAL TREE
if(length(family.taxa)==0){next}
if(length(union.tips)==0){
order<-species.table$order[species.table$family==family][!duplicated(species.table$order[species.table$family==family])]
order.taxa<- species.table$taxon[species.table$order==order]
order.taxa<- order.taxa[order.taxa%!in%tree$tip.label]
order.genera<- species.table$genus[species.table$order==order]
union.tips<-tree$tip.label[word(tree$tip.label, 1, sep="_")%in%order.genera]   #species (tips) within class IN ORIGINAL TREE
if(length(order.taxa)==0){next}
if(length(union.tips)==0){
class<- species.table$class[species.table$order==order][!duplicated(species.table$class[species.table$order==order])]
class.taxa<- species.table$taxon[species.table$class==class]
class.taxa<- class.taxa[class.taxa%!in%tree$tip.label]
class.genera<- species.table$genus[species.table$class==class]
union.tips<-tree$tip.label[word(tree$tip.label, 1, sep="_")%in%class.genera]   #species (tips) within class IN ORIGINAL TREE
if(length(class.taxa)==0){next}
if(length(union.tips)==0){message(paste0("ATTENTION: genus ", class.genera, " was not included as no Class coincidences were found"))####JOIN TO UPPER TAXONOMIC LEVEL
next}
newtree<- polytomy_over_node(tree = newtree, species = class.taxa, node=findMRCA(newtree, tips=union.tips), insertion = insertion)####JOIN TO UPPER TAXONOMIC LEVEL
next}
if(length(union.tips)==1){node<- which(newtree$tip.label==union.tips)}else{node<-findMRCA(newtree, tips=union.tips)}
newtree<- polytomy_over_node(tree = newtree, species = order.taxa, node=node, insertion = insertion)####JOIN TO UPPER TAXONOMIC LEVEL
next}
if(length(union.tips)==1){node<- which(newtree$tip.label==union.tips)}else{node<-findMRCA(newtree, tips=union.tips)}
newtree<- polytomy_over_node(tree = newtree, species = family.taxa, node=node, insertion = insertion)####JOIN TO UPPER TAXONOMIC LEVEL
next}
if(length(union.tips)==1){node<- which(newtree$tip.label==union.tips)}else{node<-findMRCA(newtree, tips=union.tips)}
newtree<- polytomy_over_node(tree = newtree, species = genus.taxa, node=node, insertion = insertion)
}}
if(type=="family.polytomy"){
families<- species.table$family[!duplicated(species.table$family)]
for(p in 1:length(families)){
family<- families[p]
family.taxa<- species.table$taxon[species.table$family==family]
family.taxa<- family.taxa[family.taxa%!in%tree$tip.label]
family.genera<- species.table$genus[species.table$family==family]
union.tips<-tree$tip.label[word(tree$tip.label, 1, sep="_")%in%family.genera]   #species (tips) within class IN ORIGINAL TREE
if(length(family.taxa)==0){next}
if(length(union.tips)==0){
order<-species.table$order[species.table$family==family][!duplicated(species.table$order[species.table$family==family])]
order.taxa<- species.table$taxon[species.table$order==order]
order.taxa<- order.taxa[order.taxa%!in%tree$tip.label]
order.genera<- species.table$genus[species.table$order==order]
union.tips<-tree$tip.label[word(tree$tip.label, 1, sep="_")%in%order.genera]   #species (tips) within class IN ORIGINAL TREE
if(length(order.taxa)==0){next}
if(length(union.tips)==0){
class<- species.table$class[species.table$order==order][!duplicated(species.table$class[species.table$order==order])]
class.taxa<- species.table$taxon[species.table$class==class]
class.taxa<- class.taxa[class.taxa%!in%tree$tip.label]
class.genera<- species.table$genus[species.table$class==class]
union.tips<-tree$tip.label[word(tree$tip.label, 1, sep="_")%in%class.genera]   #species (tips) within class IN ORIGINAL TREE
if(length(class.taxa)==0){next}
if(length(union.tips)==0){message(paste0("ATTENTION: genus ", class.genera, " was not included as no Class coincidences were found"))####JOIN TO UPPER TAXONOMIC LEVEL
next}
newtree<- polytomy_over_node(tree = newtree, species = class.taxa, node=findMRCA(newtree, tips=union.tips), insertion = insertion)####JOIN TO UPPER TAXONOMIC LEVEL
next}
if(length(union.tips)==1){node<- which(newtree$tip.label==union.tips)}else{node<-findMRCA(newtree, tips=union.tips)}
newtree<- polytomy_over_node(tree = newtree, species = order.taxa, node=node, insertion = insertion)####JOIN TO UPPER TAXONOMIC LEVEL
next}
if(length(union.tips)==1){node<- which(newtree$tip.label==union.tips)}else{node<-findMRCA(newtree, tips=union.tips)}
newtree<- polytomy_over_node(tree = newtree, species = family.taxa, node=node, insertion = insertion)}}
if(type=="order.polytomy"){
orders<- species.table$order[!duplicated(species.table$order)]
for(p in 1:length(orders)){
order<-orders[p]
order.taxa<- species.table$taxon[species.table$order==order]
order.taxa<- order.taxa[order.taxa%!in%tree$tip.label]
order.genera<- species.table$genus[species.table$order==order]
union.tips<-tree$tip.label[word(tree$tip.label, 1, sep="_")%in%order.genera]   #species (tips) within class IN ORIGINAL TREE
if(length(order.taxa)==0){next}
if(length(union.tips)==0){
class<- species.table$class[species.table$order==order][!duplicated(species.table$class[species.table$order==order])]
class.taxa<- species.table$taxon[species.table$class==class]
class.taxa<- class.taxa[class.taxa%!in%tree$tip.label]
class.genera<- species.table$genus[species.table$class==class]
union.tips<-tree$tip.label[word(tree$tip.label, 1, sep="_")%in%class.genera]   #species (tips) within class IN ORIGINAL TREE
if(length(class.taxa)==0){next}
if(length(union.tips)==0){message(paste0("ATTENTION: genus ", class.genera, " was not included as no Class coincidences were found"))####JOIN TO UPPER TAXONOMIC LEVEL
next}
newtree<- polytomy_over_node(tree = newtree, species = class.taxa, node=findMRCA(newtree, tips=union.tips), insertion = insertion)####JOIN TO UPPER TAXONOMIC LEVEL
next}
if(length(union.tips)==1){node<- which(newtree$tip.label==union.tips)}else{node<-findMRCA(newtree, tips=union.tips)}
newtree<- polytomy_over_node(tree = newtree, species = order.taxa, node=node, insertion = insertion)
}}
if(type=="class.polytomy"){
classes<- species.table$class[!duplicated(species.table$class)]
for(p in 1:length(classes)){
class<- classes[p]
class.taxa<- species.table$taxon[species.table$class==class]
class.taxa<- class.taxa[class.taxa%!in%tree$tip.label]
class.genera<- species.table$genus[species.table$class==class]
union.tips<-tree$tip.label[word(tree$tip.label, 1, sep="_")%in%class.genera]   #species (tips) within class IN ORIGINAL TREE
if(length(class.taxa)==0){next}
if(length(union.tips)==0){message(paste0("ATTENTION: genus ", class.genera, " was not included as no Class coincidences were found"))####JOIN TO UPPER TAXONOMIC LEVEL
next}
if(length(union.tips)==1){node<- which(newtree$tip.label==union.tips)}else{node<-findMRCA(newtree, tips=union.tips)}
newtree<- polytomy_over_node(tree = newtree, species = class.taxa, node=node, insertion = insertion)}}
if(type=="random"){
for(i in 1: length(taxa.genera)){        #loop 1
genus<- taxa.genera[i]
genus.type<-species.table$genus.type[species.table$genus==genus][!duplicated(species.table$genus.type[species.table$genus==genus])]
genus.taxa <- taxa[word(taxa, 1, sep="_")==genus] #genus taxa selection
genus.taxa <- sample(genus.taxa, length(genus.taxa), replace = F) #order randomized
grouped.taxa<-species.table$using.taxa[!is.na(species.table$relative.species)]#tips with no "relatives" information selected (they will be bound as monophyletic)
grouped.taxa<-grouped.taxa[grouped.taxa%in%genus.taxa]
genus.taxa<-genus.taxa[genus.taxa%!in%grouped.taxa]
if(length(grouped.taxa)>0){    #if "grouped.taxa" exist
for( j in 1:length(grouped.taxa)){
grouping.taxa<- species.table$relative.species[species.table$using.taxa==grouped.taxa[j]]
grouping.taxa<-gsub(" ","",grouping.taxa)
grouping.taxa<- strsplit(grouping.taxa, split = ",")[[1]]
grouping.taxa<-grouping.taxa[grouping.taxa%in%tree$tip.label] #taxa to be grouped hich are in the tree are selected
if(length(grouping.taxa)==1){
newtree<- add_to_singleton(newtree, singleton = grouping.taxa, new.tips = grouped.taxa[j])  #first is added as singleton
} else{
node<-findMRCA(newtree, tips = grouping.taxa)
newtree<- add_into_node(newtree, new.tip = grouped.taxa[j],node = node)} #the rest ar added as monophyletic
rm(j, node, grouping.taxa)}
next}
#forbidden.groups
forb.genera<- species.table[species.table$genus.type=="MONOPHYLETIC"|species.table$genus.type=="PARAPHYLETIC","genus"]
forb.genera<-forb.genera[!duplicated(forb.genera)]
forbidden.groups<- rep(list(NA),length(forb.genera))
for(l in 1:length(forb.genera)){
forbidden.groups[[l]]<- species.table[species.table$genus==forb.genera[l], "taxon"]
}
#Hereon we will work with genus.taxa; i.e., no grouped tips.
if(genus.type=="MONOPHYLETIC"){
for( j in 1:length(genus.taxa)){
newtree<- add_to_monophyletic(newtree, new.tip = genus.taxa[j])#for the given genus, being MP, taxa are added one by one as MP
rm(j)}}
if(genus.type=="PARAPHYLETIC"){
for( j in 1:length(genus.taxa)){
newtree<- add_to_paraphyletic(newtree, new.tip = genus.taxa[j])#for the given genus, being PaP, taxa are added one by one as PaP
rm(j)}}
if(genus.type=="POLYPHYLETIC"){
for( j in 1:length(genus.taxa)){
newtree<- add_to_polyphyletic(newtree, new.tip = genus.taxa[j])#for the given genus, being PoP, taxa are added one by one as PoP
rm(j)}}
if(genus.type=="SINGLETON GENUS"){   #for the given genus, being singleton, all tips are added in one step
newtree<- add_to_singleton(newtree, singleton = tree$tip.label[word(tree$tip.label,1,sep="_")== genus], new.tips = genus.taxa)
}
if(genus.type=="NOT INCLUDED"){
genus.synonyms<- species.table$synonim.genus[species.table$genus==genus&!is.na(species.table$synonim.genus)]#looking for synonim information...
genus.siblings<- species.table$sibling.genus[species.table$genus==genus&!is.na(species.table$sibling.genus)]#... or sibling information
genus.synonyms.tips<-species.table$using.taxa[species.table$genus==genus&!is.na(species.table$synonim.genus)]
genus.siblings.tips<-species.table$using.taxa[species.table$genus==genus&!is.na(species.table$sibling.genus)]
genus.taxa.NO.except<-genus.taxa[genus.taxa%!in%c(genus.synonyms.tips,genus.siblings.tips)]#taxa without exceptions
if(length(genus.synonyms)>0){#for genera with synonym exceptions
for(i in 1:length(genus.synonyms.tips)){
genus.synonyms.tips[i]<-paste0(genus.synonyms[i], "_",genus.synonyms.tips[i]) #synonym genus pasted to the begginig of the name; must be in the tree
new.genus<- word(genus.synonyms.tips[i], 1, sep="_")
new.genus.type<-species.table$genus.type[species.table$genus==new.genus][!duplicated(species.table$genus.type[species.table$genus==new.genus])]
if(new.genus.type=="MONOPHYLETIC"){
newtree<- add_to_monophyletic(newtree, new.tip = genus.synonyms.tips[i])}
if(new.genus.type=="PARAPHYLETIC"){
newtree<- add_to_paraphyletic(newtree, new.tip = genus.synonyms.tips[i])}
if(new.genus.type=="POLYPHYLETIC"){
newtree<- add_to_polyphyletic(newtree, species = genus.synonyms.tips[i])}
if(new.genus.type=="SINGLETON GENUS"){
newtree<- add_to_singleton(newtree,
singleton = newtree$tip.label[word(newtree$tip.label,1,sep="_")== new.genus],
new.tips = genus.synonyms.tips[i])}
newtree$tip.label<-gsub(pattern = genus.synonyms.tips[i],
replacement = species.table$using.taxa[species.table$genus==genus&!is.na(species.table$synonim.genus)][i],
x =newtree$tip.label )
}}
if(length(genus.siblings)>0){#for genera with sibling exceptions
if(length(genus.siblings[!duplicated(genus.siblings)])>1){stop(paste0("Multiple genus siblings for genus ",genus))}
new.genus<- genus.siblings[!duplicated(genus.siblings)]
genus.siblings.tips<-sample(genus.siblings.tips, length(genus.siblings.tips), replace = F)
adding.node<- findMRCA(newtree, tips = newtree$tip.label[word(newtree$tip.label, 1, sep="_")==new.genus])
newtree<-add_over_node(newtree, new.tip = genus.siblings.tips[1], node=adding.node)#it is added over the sibling genus MCRA
newtree<-add_to_singleton(newtree, singleton = genus.siblings.tips[1],new.tips =  genus.siblings.tips[2:length(genus.siblings.tips)])#te rest are added to singleton
}
if(length(genus.taxa.NO.except)>0){#for those with no exceptions, they will be added randomly within family, order or class
fam<-species.table$family[species.table$using.taxa%in%genus.taxa.NO.except][!duplicated(species.table$family[species.table$using.taxa%in%genus.taxa.NO.except])]
genera<- species.table$genus[species.table$family==fam]
if(length(genera)>0){
family.taxa<- newtree$tip.label[word(newtree$tip.label,1, sep="_")%in%genera]
newtree<- add_into_node_exceptions(tree=newtree, node=findMRCA(tree = newtree,tips = family.taxa),new.tip = genus.taxa.NO.except[1], exception.list = forbidden.groups)
if(length(genus.taxa.NO.except)>1){newtree<- add_to_singleton(tree=newtree, singleton = genus.taxa.NO.except[1],new.tips = genus.taxa.NO.except[2:length(genus.taxa.NO.except)])}
}else{
ord<-species.table$order[species.table$using.taxa%in%genus.taxa.NO.except][!duplicated(species.table$family[species.table$using.taxa%in%genus.taxa.NO.except])]
genera<- species.table$genus[species.table$order==ord]
if(length(genera)>0){
order.taxa<- newtree$tip.label[word(newtree$tip.label,1, sep="_")%in%genera]
newtree<- add_into_node_exceptions(tree=newtree, node=findMRCA(tree = newtree,tips = order.taxa),new.tip = genus.taxa.NO.except[1], exception.list = forbidden.groups)
if(length(genus.taxa.NO.except)>1){newtree<- add_to_singleton(tree=newtree, singleton = genus.taxa.NO.except[1],new.tips = genus.taxa.NO.except[2:length(genus.taxa.NO.except)])}
}else{
cla<-species.table$class[species.table$using.taxa%in%genus.taxa.NO.except][!duplicated(species.table$family[species.table$using.taxa%in%genus.taxa.NO.except])]
genera<- species.table$genus[species.table$class==cla]
if(length(genera)>0){
class.taxa<- newtree$tip.label[word(newtree$tip.label,1, sep="_")%in%genera]
newtree<- add_into_node_exceptions(tree=newtree, node=findMRCA(tree = newtree,tips = class.taxa),new.tip = genus.taxa.NO.except[1], exception.list = forbidden.groups)
if(length(genus.taxa.NO.except)>1){newtree<- add_to_singleton(tree=newtree, singleton = genus.taxa.NO.except[1],new.tips = genus.taxa.NO.except[2:length(genus.taxa.NO.except)])}
}else{
stop(paste0("Genus ", genus, " has no family, order or class relatives"))}}}
}
}
print(paste0(i, " out of ", length(taxa.genera), ". Genus ", genus, " (", genus.type,"): ", round(i/length(taxa.genera)*100, 2), " %"))
}
# phase 2. subspecies
if(nrow(species.table.dupl)>0){ #species grouped
rep.taxa <-species.table.dupl$taxon #species are found
rep.taxa.species<- species.table.dupl$using.taxa[!duplicated(species.table.dupl$using.taxa)]#subspecies' species
for (r in 1:length(rep.taxa.species)){
ssps <- rep.taxa[paste0(word(rep.taxa, 1, sep="_"),"_",word(rep.taxa, 2, sep="_"))==rep.taxa.species[r]] #subspecies within species are selected
ssps <- sample(ssps, length(ssps), replace = F) #order randomized
sp.to.add<- newtree$tip.label[paste0(word(newtree$tip.label,1, sep="_"), "_", word(newtree$tip.label,2, sep="_"))== rep.taxa.species[r] ]
newtree<- add_to_singleton(newtree, singleton = sp.to.add, new.tips = ssps) #subspecies are added to their sister as singleton
}
}
for(n in 1:nrow(species.table)){  #original names are returned
if(species.table$using.taxa[n]== species.table$taxon[n]){next}
if(species.table$using.taxa[n]%!in% newtree$tip.label){next}
if(species.table$using.taxa[n]%in% newtree$tip.label){
newtree$tip.label[newtree$tip.label==species.table$using.taxa[n]]<-species.table$taxon[n]
}}
}
return(newtree)
}
plot(RANDTIP(tree=Tree, species.table=tabla.info, aggregate.subspecies=TRUE, type = "random"))
plot(RANDTIP(tree=Tree, species.table=tabla.info, aggregate.subspecies=TRUE, type = "random"))
plot(RANDTIP(tree=Tree, species.table=tabla.info, aggregate.subspecies=TRUE, type = "random"))
plot(RANDTIP(tree=Tree, species.table=tabla.info, aggregate.subspecies=TRUE, type = "random"))
plot(RANDTIP(tree=Tree, species.table=tabla.info, aggregate.subspecies=TRUE, type = "random"))
plot(RANDTIP(tree=Tree, species.table=tabla.info, aggregate.subspecies=TRUE, type = "random"))
plot(RANDTIP(tree=Tree, species.table=tabla.info, aggregate.subspecies=TRUE, type = "random"))
plot(RANDTIP(tree=Tree, species.table=tabla.info, aggregate.subspecies=TRUE, type = "random"))
?set.seed()
set.seed(123)
seed
set.seed()
set.seed
seed<-1234
set.seed(1)
plot(RANDTIP(tree=Tree, species.table=tabla.info, aggregate.subspecies=TRUE, type = "random", set.seed(1)))
plot(RANDTIP(tree=Tree, species.table=tabla.info, aggregate.subspecies=TRUE, type = "random", set.seed(1)))
plot(RANDTIP(tree=Tree, species.table=tabla.info, aggregate.subspecies=TRUE, type = "random", set.seed(1)))
plot(RANDTIP(tree=Tree, species.table=tabla.info, aggregate.subspecies=TRUE, type = "random", set.seed(1)))
plot(RANDTIP(tree=Tree, species.table=tabla.info, aggregate.subspecies=TRUE, type = "random", set.seed(1)))
plot(RANDTIP(tree=Tree, species.table=tabla.info, aggregate.subspecies=TRUE, type = "random", set.seed(1)))
plot(RANDTIP(tree=Tree, species.table=tabla.info, aggregate.subspecies=TRUE, type = "random", set.seed(1)))
plot(RANDTIP(tree=Tree, species.table=tabla.info, aggregate.subspecies=TRUE, type = "random", set.seed(1)))
plot(RANDTIP(tree=Tree, species.table=tabla.info, aggregate.subspecies=TRUE, type = "random", set.seed(1)))
plot(RANDTIP(tree=Tree, species.table=tabla.info, aggregate.subspecies=TRUE, type = "random", set.seed(1)))
plot(RANDTIP(tree=Tree, species.table=tabla.info, aggregate.subspecies=TRUE, type = "random", set.seed(1)))
library(gsheet)
library(stringi)
library(ggplot2)
library(gridExtra)
gastos<-gsheet2tbl('https://docs.google.com/spreadsheets/d/1pUJv3WacwNaGQZM20gRwCL8LrArmLHEXKmuDRrkWrg8/edit#gid=249967951')
gastos$CANTIDAD<-sub(",", ".", gastos$CANTIDAD)
gastos$CANTIDAD<- as.numeric(gastos$CANTIDAD)
calculos.contabilidad<- function(data,persona=c("casa", "ignacio"), mes=NULL, income=1100){
gastos<-data
if(persona=="ignacio"){gastos<-gastos[gastos$CUENTA=="IGNACIO",]}else{gastos<-gastos[gastos$CUENTA=="CASA",]}
if(!is.null(mes)){gastos<- gastos[stri_sub(gastos$DÍA, -7, -1)==mes,]}
tabla.res<- aggregate(gastos$CANTIDAD, by=list(gastos$CATEGORÍA), FUN=sum)
colnames(tabla.res)[1]<-"TIENDA"
colnames(tabla.res)[2]<-"GASTO"#gastos por meses y tabla resumen
gastos$DÍA<- as.Date(gastos$DÍA, format = "%d/%m/%y")
p2<- ggplot(gastos)+
geom_bar(aes(DÍA, CANTIDAD, fill=CATEGORÍA),position="stack", stat="identity")+
labs(title = "EVOLUCIÓN DE GASTOS")+
scale_x_date(date_labels = "%d")+
scale_fill_brewer(palette = "Dark2")+
theme(
plot.title = element_text(face="bold", size=14, hjust = 0.5),
axis.text.x = element_text(face="bold", size=8, hjust = 0.5),
legend.position = "none")
p1<-ggplot(tabla.res)+
geom_col(aes(x=0, y=GASTO, fill=paste0(TIENDA,":  ", GASTO, " \U20AC")))+
coord_polar(theta = "y")+
scale_x_continuous(breaks=NULL)+
xlab(NULL)+
ylab(NULL)+
labs(title = "PROPORCIÓN DE GASTOS", fill="TIENDA")+
scale_fill_brewer(palette = "Dark2")+
geom_text(aes(x=0.3, y = sum(GASTO)-(cumsum(GASTO) - GASTO/2), label=substr(TIENDA, 1,3)))+
theme(
plot.title = element_text(face="bold", size=14, hjust = 0.5),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
axis.text = element_blank(),
panel.background = element_rect(fill = "transparent", color = NA),
plot.background  = element_rect(fill = "transparent", color = NA),
legend.position = "left"  )
if(sum(gastos$CANTIDAD)<income){
p3<-ggplot(gastos)+
geom_col(aes(x=1, y=income), fill="#2FAD2F")+
scale_x_discrete()+
geom_col(aes(x=1, y=(CANTIDAD)), fill="#CA3434")+
scale_y_continuous(limits = c(0,income+100))+
labs(title = paste0("AHORRO: ","\n", income-(sum(gastos$CANTIDAD)), "  \U20AC" ))+
theme(
plot.title = element_text(face="bold", size=14, hjust = 0.5),
panel.background = element_rect(fill = "transparent", color = NA),
plot.background  = element_rect(fill = "transparent", color = NA),
axis.title.x = element_blank(),
axis.title.y = element_blank()
)+
geom_hline(yintercept = sum(gastos$CANTIDAD), colour="red", lwd=2, lty=2)
}else{
p3<-ggplot(gastos)+
geom_col(aes(x=1, y=CANTIDAD), fill="black")+
scale_x_discrete()+
geom_col(aes(x=1, y=income), fill="#CA3434")+     #350*3 es el mínimo!
scale_y_continuous(limits = c(0,income+100))+
labs(title = paste0("SOBREGASTO: ","\n", (sum(gastos$CANTIDAD))-income, "  \U20AC" ))+ #350+360+390 es el mínimo!
theme(
plot.title = element_text(face="bold", size=14, hjust = 0.5),
panel.background = element_rect(fill = "transparent", color = NA),
plot.background  = element_rect(fill = "transparent", color = NA),
axis.title.x = element_blank(),
axis.title.y = element_blank()
)+
geom_hline(yintercept = sum(gastos$CANTIDAD), colour="red", lwd=2, lty=2)
}
return(list(gastos, p1, p2, p3))
}
contabilidad<- calculos.contabilidad(data=gastos, persona="ignacio", mes="01/2021", income=1200)
x11()
grid.arrange(contabilidad[[2]], contabilidad[[3]], contabilidad[[4]],
widths = c(2, 1, 1),
layout_matrix = rbind(c(1, 1, 2),
c(1, 1, 3)))
grid.arrange(contabilidad[[2]], contabilidad[[3]], contabilidad[[4]],
widths = c(2, 1, 1),
layout_matrix = rbind(c(1, 1, 2),
c(1, 1, 3)))
View(contabilidad[[1]])   #para ver la tabla
contabilidad<- calculos.contabilidad(data=gastos, persona="casa", mes="01/2021", income=1200)
grid.arrange(contabilidad[[2]], contabilidad[[3]], contabilidad[[4]],
widths = c(2, 1, 1),
layout_matrix = rbind(c(1, 1, 2),
c(1, 1, 3)))
contabilidad<- calculos.contabilidad(data=gastos, persona="casa", mes="01/2021", income=1100)
grid.arrange(contabilidad[[2]], contabilidad[[3]], contabilidad[[4]],
widths = c(2, 1, 1),
layout_matrix = rbind(c(1, 1, 2),
c(1, 1, 3)))
View(contabilidad[[1]])   #para ver la tabla
contabilidad<- calculos.contabilidad(data=gastos, persona="casa", mes="01/2021", income=1200)
#creación de gr?ficas
x11()
grid.arrange(contabilidad[[2]], contabilidad[[3]], contabilidad[[4]],
widths = c(2, 1, 1),
layout_matrix = rbind(c(1, 1, 2),
c(1, 1, 3)))
